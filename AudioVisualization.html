<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Y2K VISUALIZER // SYSTEM AUDIO MODE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        /* --- GLOBAL RESET & FIX --- */
        * {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body { 
            margin: 0; overflow: hidden; 
            background-color: #000; 
            font-family: 'Share Tech Mono', monospace; 
            color: #00f3ff; /* Cyber Cyan */
        }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* --- HUD LAYER --- */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 10; pointer-events: none; 
            display: flex; flex-direction: column; justify-content: space-between; 
            padding: 30px; 
        }
        
        /* Glassmorphism Panel */
        .panel { 
            background: rgba(10, 20, 30, 0.6); 
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 243, 255, 0.3); 
            border-radius: 4px;
            padding: 20px; 
            pointer-events: auto; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            min-width: 300px;
            max-width: 340px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .panel:hover {
            border-color: rgba(0, 243, 255, 0.6);
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.15);
        }

        h1 { 
            margin: 0 0 10px 0; 
            font-size: 1.6rem; 
            letter-spacing: 3px; 
            border-bottom: 1px solid rgba(0, 243, 255, 0.3); 
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
        }
        
        h1::after {
            content: 'â— LIVE';
            font-size: 0.8rem;
            color: #ff0055;
            animation: pulse 2s infinite;
        }

        /* Controls */
        .control-group { margin-top: 15px; }
        label { 
            display: flex; justify-content: space-between; margin-top: 12px; 
            font-size: 0.85rem; color: rgba(255, 255, 255, 0.7); 
            letter-spacing: 1px;
        }
        
        /* Styled Range Sliders */
        input[type="range"] { -webkit-appearance: none; width: 100%; background: transparent; margin: 8px 0; }
        input[type="range"]:focus { outline: none; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; background: #00f3ff; border: 2px solid #000; border-radius: 50%; cursor: pointer; margin-top: -5px; box-shadow: 0 0 10px #00f3ff; transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        /* File Button -> Now Capture Button */
        .file-btn {
            display: flex; justify-content: center; align-items: center; width: 100%; padding: 12px 0; margin-top: 10px;
            background: rgba(0, 243, 255, 0.1); border: 1px solid rgba(0, 243, 255, 0.5); color: #00f3ff;
            font-family: 'Share Tech Mono', monospace; font-size: 1rem; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            user-select: none;
        }
        .file-btn:hover { background: rgba(0, 243, 255, 0.2); box-shadow: 0 0 15px rgba(0, 243, 255, 0.3); text-shadow: 0 0 5px #00f3ff; border-color: #00f3ff; }
        .file-btn:active { background: rgba(0, 243, 255, 0.4); }
        
        .val-display { color: #fff; text-shadow: 0 0 5px rgba(255,255,255,0.5); }
        
        #mode-display { font-size: 1.8rem; color: #d000ff; text-align: right; text-shadow: 0 0 10px rgba(208, 0, 255, 0.6); }
        
        /* Spectrum Visualizer */
        .spectrum { display: flex; gap: 4px; height: 30px; margin-top: 10px; align-items: flex-end; justify-content: flex-end; }
        .spec-bar { width: 40px; background: #333; height: 4px; transition: height 0.08s ease-out; position: relative; }
        #vis-low { background: linear-gradient(to top, #5500ff, #ff00ff); box-shadow: 0 0 10px #ff00ff; }
        #vis-mid { background: linear-gradient(to top, #0055ff, #00f3ff); box-shadow: 0 0 10px #00f3ff; }
        #vis-high { background: linear-gradient(to top, #ffaa00, #ffffaa); box-shadow: 0 0 10px #ffffaa; }
        
        .top-row { display: flex; justify-content: space-between; align-items: flex-start; }
        .section-title { font-size: 0.8rem; color: rgba(255,255,255,0.4); margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom:2px;}
        
        .warning-text {
            font-size: 0.65rem; color: #ff0055; text-align: center; margin-top: 5px; 
            animation: pulse 3s infinite;
        }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="top-row">
            
            <div class="panel" style="text-align: right; min-width: 200px; margin-left: auto;">
                <div class="section-title">GEOMETRY ENGINE</div>
                <div id="mode-display">WORMHOLE</div>
                <div style="font-size: 0.75rem; margin-top:5px; color:rgba(255,255,255,0.5);">PRESS [SPACE] TO MORPH</div>
                
                <div style="margin-top: 20px;">
                    <div class="section-title" style="text-align: right;">SPECTRAL ANALYZER</div>
                    <div class="spectrum">
                        <div id="vis-low" class="spec-bar"></div>
                        <div id="vis-mid" class="spec-bar"></div>
                        <div id="vis-high" class="spec-bar"></div>
                    </div>
                    <div style="font-size: 0.7rem; display:flex; justify-content:flex-end; gap:25px; color:rgba(255,255,255,0.5); margin-top:2px;">
                        <span>L</span><span>M</span><span>H</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel" style="margin-top: auto; transform: scale(0.6667); transform-origin: bottom left;">
            <div class="section-title">// SYSTEM_AUDIO_LINK</div>
            
            <div id="startBtn" class="file-btn">
                [ START_SYSTEM_CAPTURE ]
            </div>
            <div class="warning-text">MUST CHECK "SHARE AUDIO" IN POPUP</div>

            <div class="control-group">
                <label>LOW FREQ [BASS] <span id="v-low" class="val-display">2.0</span></label>
                <input type="range" id="lowRange" min="0" max="5.0" step="0.1" value="2.0">

                <label>MID FREQ [SWIRL] <span id="v-mid" class="val-display">2.0</span></label>
                <input type="range" id="midRange" min="0" max="5.0" step="0.1" value="2.0">
                
                <label>HIGH FREQ [SHIMMER] <span id="v-high" class="val-display">2.0</span></label>
                <input type="range" id="highRange" min="0" max="5.0" step="0.1" value="2.0">

                <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 15px 0;"></div>

                <label>PARTICLE DENSITY <span id="v-size" class="val-display">2.0</span></label>
                <input type="range" id="sizeRange" min="1.0" max="5.0" step="0.1" value="2.0">
                
                <label>BLOOM INTENSITY <span id="v-glow" class="val-display">1.8</span></label>
                <input type="range" id="glowRange" min="0.5" max="3.5" step="0.1" value="1.8">
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        

        // --- 1. CONFIG & SCENE ---
        const COUNT = 36000; 
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000); 
        camera.position.set(0, 100, 900);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.8;
        bloomPass.radius = 0.6;
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;

        // --- 2. PARTICLES & GEOMETRY ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const targetPositions = new Float32Array(COUNT * 3);
        const colors = new Float32Array(COUNT * 3); 
        const sizes = new Float32Array(COUNT);

        // --- EXPANDED SHAPE COLLECTION ---
        const shapes = { 
            wormhole: [], data_helix: [], cyber_grid: [], stargate: [], nebula_knot: [],
            mobius_strip: [], lorenz_attractor: [], hyper_torus: [], fibonacci_sphere: []
        };

        // --- SHAPE GENERATORS (UNCHANGED) ---
        // 1. WORMHOLE
        for(let i=0; i<COUNT; i++) {
            const t = i / COUNT; const angle = t * Math.PI * 40; const z = (t - 0.5) * 3500; 
            const radius = 300 + Math.pow(Math.abs(t - 0.5) * 2, 2) * 1400;
            shapes.wormhole.push(Math.cos(angle)*radius + (Math.random()-0.5)*80, Math.sin(angle)*radius + (Math.random()-0.5)*80, z);
        }
        // 2. DATA HELIX
        for(let i=0; i<COUNT; i++) {
            const t = i / COUNT; const angle = t * Math.PI * 30; const height = (t - 0.5) * 2800;
            const radius = 650; const strandOffset = (i % 2 === 0) ? 0 : Math.PI; const br = Math.random() > 0.95 ? 380 : 40;
            shapes.data_helix.push(Math.cos(angle+strandOffset)*radius + (Math.random()-0.5)*br, height, Math.sin(angle+strandOffset)*radius + (Math.random()-0.5)*br);
        }
        // 3. CYBER GRID
        const gridSize = Math.sqrt(COUNT); const spacing = 75;
        for(let i=0; i<COUNT; i++) {
            const ix = i % gridSize; const iz = Math.floor(i / gridSize);
            const x = (ix - gridSize/2) * spacing; const z = (iz - gridSize/2) * spacing;
            const y = Math.sin(x*0.005) * Math.cos(z*0.005) * 600 + (Math.random()-0.5)*80;
            shapes.cyber_grid.push(x, y, z);
        }
        // 4. STARGATE
        for(let i=0; i<COUNT; i++) {
            const u = i / COUNT * Math.PI * 2; const p = 3; const q = 7; const r = 900 + 220 * Math.cos(q * u);
            shapes.stargate.push(r * Math.cos(p * u), r * Math.sin(p * u), 220 * Math.sin(q * u) * 2.5 + (Math.random()-0.5)*120);
        }
        // 5. NEBULA KNOT
        for(let i=0; i<COUNT; i++) {
             const t = (i/COUNT) * Math.PI * 120; const scale = 800;
             shapes.nebula_knot.push(scale*(Math.cos(t)+Math.cos(3*t))*0.5+(Math.random()-0.5)*260, scale*(Math.sin(t)+Math.sin(3*t))*0.5+(Math.random()-0.5)*260, scale*Math.sin(4*t)*0.5+(Math.random()-0.5)*380);
        }
        // 6. MOBIUS STRIP
        for(let i=0; i<COUNT; i++) {
            const u = (i/COUNT) * Math.PI * 2; const w = (Math.random() - 0.5) * 400; const R = 800;
            shapes.mobius_strip.push((R + w*Math.cos(u/2))*Math.cos(u), (R + w*Math.cos(u/2))*Math.sin(u), w*Math.sin(u/2));
        }
        // 7. LORENZ ATTRACTOR (Chaos)
        let lx=0.1, ly=0, lz=0; const dt=0.005; const sigma=10, rho=28, beta=8/3; const scaleL=35;
        for(let i=0; i<COUNT; i++) {
            let dx = sigma*(ly-lx)*dt; let dy = (lx*(rho-lz)-ly)*dt; let dz = (lx*ly-beta*lz)*dt;
            lx+=dx; ly+=dy; lz+=dz;
            shapes.lorenz_attractor.push(lx*scaleL, ly*scaleL, (lz-25)*scaleL);
        }
        // 8. HYPER TORUS
        for(let i=0; i<COUNT; i++) {
            const u = (i/COUNT) * Math.PI * 4; const v = (i/COUNT) * Math.PI * 20; 
            const R = 800; const r1 = 280; const r2 = 160;
            const rDyn = r1 + r2 * Math.cos(v);
            shapes.hyper_torus.push((R + rDyn*Math.cos(u))*Math.cos(v*0.1), (R + rDyn*Math.cos(u))*Math.sin(v*0.1), rDyn*Math.sin(u) + Math.sin(v)*100);
        }
        // 9. FIBONACCI SPHERE
        const phi = Math.PI * (3.0 - Math.sqrt(5.0)); 
        for(let i=0; i<COUNT; i++) {
            const y = 1 - (i / (COUNT - 1)) * 2; const radius = Math.sqrt(1 - y * y);
            const theta = phi * i; const R = 900;
            shapes.fibonacci_sphere.push(Math.cos(theta)*radius*R, y*R, Math.sin(theta)*radius*R);
        }


        // Init
        for(let i=0; i<COUNT*3; i++) {
            positions[i] = shapes.wormhole[i];
            targetPositions[i] = shapes.wormhole[i];
            colors[i] = Math.random(); 
        }
        for(let i=0; i<COUNT; i++) sizes[i] = Math.random();

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('colorAttr', new THREE.BufferAttribute(colors, 1)); 
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // --- SHADER ---
        const uniforms = {
            uTime: { value: 0 },
            uBass: { value: 0 }, uMid: { value: 0 }, uHigh: { value: 0 },
            uLowAmp: { value: 2.0 }, uMidAmp: { value: 2.0 }, uHighAmp: { value: 2.0 },
            uBaseSize: { value: 2.0 }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
                uniform float uTime;
                uniform float uBass; uniform float uMid; uniform float uHigh;
                uniform float uLowAmp; uniform float uMidAmp; uniform float uHighAmp;
                uniform float uBaseSize;
                attribute float size; attribute float colorAttr; 
                varying float vType; varying float vIntensity;
                void main() {
                    vType = colorAttr; vec3 pos = position;
                    float isBass = 1.0 - step(0.33, colorAttr); float isHigh = step(0.66, colorAttr); float isMid = 1.0 - isBass - isHigh;
                    vec3 dir = normalize(pos);
                    
                    // 1. Bass
                    vec3 moveBass = dir * uBass * 80.0 * uLowAmp;
                    // 2. Mid (Vortex)
                    float swirlAngle = uMid * uMidAmp * 0.5; float s = sin(swirlAngle); float c = cos(swirlAngle);
                    float nx = pos.x * c - pos.z * s; float nz = pos.x * s + pos.z * c;
                    vec3 moveMid = (vec3(nx, pos.y, nz) - pos) * isMid;
                    // 3. High (Shimmer)
                    float noise = sin(uTime * 8.0 + pos.x); vec3 moveHigh = dir * noise * uHigh * 5.0 * uHighAmp;
                    
                    pos += (moveBass * isBass) + moveMid + (moveHigh * isHigh);
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_Position = projectionMatrix * mvPosition;
                    
                    float beatSize = 1.0 + (isBass * uBass * uLowAmp) + (isHigh * uHigh * uHighAmp);
                    gl_PointSize = (uBaseSize * size * beatSize * 3.0) * (300.0 / -mvPosition.z);
                    vIntensity = (isBass * uBass) + (isMid * uMid) + (isHigh * uHigh);
                }
            `,
            fragmentShader: `
                varying float vType; varying float vIntensity;
                void main() {
                    if (dot(gl_PointCoord - 0.5, gl_PointCoord - 0.5) > 0.25) discard;
                    vec3 colBass = vec3(1.0, 0.0, 0.5); vec3 colMid = vec3(0.0, 1.0, 0.8); vec3 colHigh = vec3(1.0, 1.0, 0.5);
                    float isBass = 1.0 - step(0.33, vType); float isHigh = step(0.66, vType); float isMid = 1.0 - isBass - isHigh;
                    vec3 finalCol = (colBass * isBass) + (colMid * isMid) + (colHigh * isHigh);
                    finalCol += vec3(vIntensity * 0.8);
                    gl_FragColor = vec4(finalCol, 0.85);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- UI EVENTS ---
        const rLow = document.getElementById('lowRange'); const vLow = document.getElementById('v-low'); rLow.addEventListener('input', (e) => { uniforms.uLowAmp.value = parseFloat(e.target.value); vLow.innerText = e.target.value; });
        const rMid = document.getElementById('midRange'); const vMid = document.getElementById('v-mid'); rMid.addEventListener('input', (e) => { uniforms.uMidAmp.value = parseFloat(e.target.value); vMid.innerText = e.target.value; });
        const rHigh = document.getElementById('highRange'); const vHigh = document.getElementById('v-high'); rHigh.addEventListener('input', (e) => { uniforms.uHighAmp.value = parseFloat(e.target.value); vHigh.innerText = e.target.value; });
        const rSize = document.getElementById('sizeRange'); const vSize = document.getElementById('v-size'); rSize.addEventListener('input', (e) => { uniforms.uBaseSize.value = parseFloat(e.target.value); vSize.innerText = e.target.value; });
        const rGlow = document.getElementById('glowRange'); const vGlow = document.getElementById('v-glow'); rGlow.addEventListener('input', (e) => { bloomPass.strength = parseFloat(e.target.value); vGlow.innerText = e.target.value; });

        // --- AUDIO SYSTEM CAPTURE ---
        let analyser, dataArray; let sBass = 0, sMid = 0, sHigh = 0;
        let ac;

        document.getElementById('startBtn').addEventListener('click', async () => {
            try {
                // Request screen sharing with audio
                // User MUST select a tab or screen and check "Share Audio"
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true, // Video is required to get the prompt with "Share Audio" checkbox
                    audio: true
                });

                // Check if we actually got an audio track
                if (stream.getAudioTracks().length === 0) {
                    alert("No audio detected. Please reload and make sure to check 'Share Audio' in the popup.");
                    return;
                }

                // Initialize AudioContext
                if (!ac) ac = new (window.AudioContext || window.webkitAudioContext)();
                
                // Close previous stream if any (optional cleanup)
                if (analyser) { /* logic to disconnect if needed */ }

                analyser = ac.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                // Create source from the captured stream
                const src = ac.createMediaStreamSource(stream);
                src.connect(analyser);
                
                // NOTE: We do NOT connect to ac.destination (speakers) to avoid echo/feedback loop.
                // The user already hears the system audio. 
                
                // Visual indicator that it worked
                document.getElementById('startBtn').innerText = "[ AUDIO LINKED ]";
                document.getElementById('startBtn').style.color = "#00ff00";
                document.getElementById('startBtn').style.borderColor = "#00ff00";

                // Stop the video track to save resources (we only need audio)
                // Note: Some browsers might stop audio if video is stopped, but usually it's fine for getDisplayMedia
                // If visuals freeze, comment out the next line:
                // stream.getVideoTracks()[0].stop(); 

            } catch (err) {
                console.error("Error capturing audio:", err);
                alert("Capture failed or cancelled. Ensure you are on HTTPS or localhost.");
            }
        });

        // --- KEYBOARD CONTROLS ---
        const keys = Object.keys(shapes); let curShape = 0;
        window.addEventListener('keydown', (e) => { if(e.code === 'Space') { curShape = (curShape + 1) % keys.length; document.getElementById('mode-display').innerText = keys[curShape].toUpperCase(); const arr = shapes[keys[curShape]]; for(let i=0; i<COUNT*3; i++) targetPositions[i] = arr[i]; } });

        // --- ANIMATION LOOP ---
        const barLow = document.getElementById('vis-low'); const barMid = document.getElementById('vis-mid'); const barHigh = document.getElementById('vis-high');
        
        function animate(time) { 
            requestAnimationFrame(animate); 
            const dt = 0.016; 
            
            let rBass = 0, rMid = 0, rHigh = 0;
            
            if(analyser) { 
                analyser.getByteFrequencyData(dataArray); 
                const len = dataArray.length; 
                
                // Bass (Low Freqs)
                let bSum=0, bEnd=Math.floor(len*0.02); 
                for(let i=0;i<bEnd;i++) bSum+=dataArray[i]; 
                rBass=(bSum/bEnd)/255; 
                
                // Mid (Vocals/Mids)
                let mSum=0, mEnd=Math.floor(len*0.3); 
                for(let i=bEnd;i<mEnd;i++) mSum+=dataArray[i]; 
                rMid=(mSum/(mEnd-bEnd))/255; 
                
                // High (Treble)
                let hSum=0; 
                for(let i=mEnd;i<len;i++) hSum+=dataArray[i]; 
                rHigh=(hSum/(len-mEnd))/255; 
            }

            // Adjust sensitivity
            rHigh = Math.min(rHigh * 1.8, 1.0); 
            if(rBass<0.25) rBass=0; 
            if(rMid<0.2) rMid=0; 
            if(rHigh<0.05) rHigh=0;

            // Smooth values
            if(rBass>sBass) sBass+=(rBass-sBass)*0.6; else sBass+=(rBass-sBass)*0.15; 
            sMid+=(rMid-sMid)*0.2; 
            sHigh+=(rHigh-sHigh)*0.4;

            // Update Uniforms
            uniforms.uTime.value=time*0.001; 
            uniforms.uBass.value=sBass; 
            uniforms.uMid.value=sMid; 
            uniforms.uHigh.value=sHigh;

            // Update UI Bars
            barLow.style.height=(sBass*100)+"%"; 
            barMid.style.height=(sMid*100)+"%"; 
            barHigh.style.height=(sHigh*100)+"%";

            // Particle Geometry Morphing
            const pos = geometry.attributes.position.array; 
            for(let i=0;i<COUNT*3;i++) pos[i]+=(targetPositions[i]-pos[i])*0.03; 
            geometry.attributes.position.needsUpdate=true;

            controls.update(); 
            composer.render(); 
        }
        
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
        
        animate(0);
    </script>
</body>
</html>